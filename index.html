<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Drag and Drop AI Model Builder</title>
  <style>
      body {
      display: flex;
      margin: 0;
      font-family: Arial, sans-serif;
      height: 100vh;
      overflow: hidden;
      background-color: #f5f5f5; /* Light gray background */
    }
    
    #sidebar {
      width: 250px;
      background-color: #2c3e50; /* Dark blue-gray */
      padding: 20px;
      border-right: 2px solid #34495e; /* Slightly darker border */
      display: flex;
      flex-direction: column;
      gap: 10px;
      color: #ecf0f1; /* Light gray text */
    }
    
    .component {
      background-color: #3498db; /* Bright blue */
      color: white;
      padding: 15px;
      border-radius: 5px;
      cursor: grab;
      text-align: center;
      margin-bottom: 10px;
      user-select: none;
      transition: background-color 0.3s ease;
    }
    
    .component:hover {
      background-color: #2980b9; /* Darker blue on hover */
    }
    
    #workspace {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    #canvas {
      flex: 1;
      position: relative;
      background-color: #ffffff; /* White canvas */
      overflow: auto;
    }
    
    .node {
      position: absolute;
      width: 150px;
      background-color: #3498db; /* Bright blue */
      color: white;
      padding: 15px;
      border-radius: 5px;
      cursor: move;
      text-align: center;
      user-select: none;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Subtle shadow */
      transition: background-color 0.3s ease;
    }
    
    .node:hover {
      background-color: #2980b9; /* Darker blue on hover */
    }
    
    .node select, .node input[type="file"] {
      width: 100%;
      margin-top: 10px;
      padding: 5px;
      border-radius: 3px;
      border: 1px solid #ccc;
      background-color: #ffffff; /* White background for inputs */
      color: #2c3e50; /* Dark text for inputs */
    }
    
    .delete-button {
      position: absolute;
      top: -10px;
      right: -10px;
      background-color: #e74c3c; /* Red */
      color: white;
      border: none;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Subtle shadow */
      transition: background-color 0.3s ease;
    }
    
    .delete-button:hover {
      background-color: #c0392b; /* Darker red on hover */
    }
    
    #code-panel {
      height: 300px;
      background-color: #ecf0f1; /* Light gray */
      border-top: 2px solid #bdc3c7; /* Light gray border */
      padding: 20px;
      overflow: auto;
      color: #2c3e50; /* Dark text */
    }
    
    svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    line {
      stroke: #3498db; /* Bright blue for connections */
      stroke-width: 2;
      marker-end: url(#arrowhead);
    }
    
    #generateButton {
      margin: 20px;
      padding: 10px 20px;
      background-color: #27ae60; /* Green */
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }
    
    #generateButton:hover {
      background-color: #219653; /* Darker green on hover */
    }
    
    #loadingSpinner {
      display: none;
      margin: 10px;
      font-size: 16px;
      color: #2c3e50; /* Dark text */
    }

    #apiKeyInput {
      width: 100%;
      padding: 8px;
      border-radius: 3px;
      border: 1px solid #ccc;
      margin-top: 10px;
      background-color: #ffffff; /* White background */
      color: #2c3e50; /* Dark text */
    }

    #apiKeyInput::placeholder {
      color: #95a5a6; /* Light gray placeholder */
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>Components</h2>
    <div class="component" draggable="true" data-type="data">Data Input</div>
    <div class="component" draggable="true" data-type="explore">Data Exploration</div>
    <div class="component" draggable="true" data-type="feature">Feature Engineering</div>
    <div class="component" draggable="true" data-type="preprocess">Preprocessing</div>
    <div class="component" draggable="true" data-type="model">Model Selection</div>
    <div class="component" draggable="true" data-type="tune">Model Tuning</div>
    <div class="component" draggable="true" data-type="validate">Validation</div>
    <div class="component" draggable="true" data-type="evaluate">Evaluation</div>
    <div class="component" draggable="true" data-type="deploy">Deployment</div>
    <input type="text" id="apiKeyInput" placeholder="Enter Gemini API Key">
    <button id="generateButton">Generate Code</button>
  </div>
  
  <div id="workspace">
    <div id="canvas">
      <svg>
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                  refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#3498db"/> <!-- Bright blue arrowhead -->
          </marker>
        </defs>
      </svg>
    </div>
    <div id="code-panel">
      <pre id="generatedCode"></pre>
    </div>
  </div>

  <script>
    const DEFAULT_API_KEY = "YOUR_DEFAULT_API_KEY"; // Replace with a default API key if needed
    let apiKey = localStorage.getItem('geminiApiKey') || DEFAULT_API_KEY;
    let nodes = [];
    let connections = [];
    let startNode = null;
    let userData = null;

    // Load API key from localStorage and set it in the input field
    const apiKeyInput = document.getElementById('apiKeyInput');
    apiKeyInput.value = apiKey;

    // Save API key to localStorage when the input changes
    apiKeyInput.addEventListener('input', (e) => {
      apiKey = e.target.value;
      localStorage.setItem('geminiApiKey', apiKey);
    });

    const NodeTypes = {
      DATA: 'data',
      EXPLORE: 'explore',
      FEATURE: 'feature',
      PREPROCESS: 'preprocess',
      MODEL: 'model',
      TUNE: 'tune',
      VALIDATE: 'validate',
      EVALUATE: 'evaluate',
      DEPLOY: 'deploy'
    };

    const NodeTemplates = {
      [NodeTypes.DATA]: `
        Data Input
        <input type="file" accept=".csv">
      `,
      [NodeTypes.EXPLORE]: `
        Data Exploration
        <select>
          <option value="summary">Summary Statistics</option>
          <option value="missing">Check Missing Values</option>
          <option value="visualize">Visualize Data</option>
        </select>
      `,
      [NodeTypes.FEATURE]: `
        Feature Engineering
        <select>
          <option value="encoding">Categorical Encoding</option>
          <option value="scaling">Feature Scaling</option>
          <option value="selection">Feature Selection</option>
        </select>
      `,
      [NodeTypes.PREPROCESS]: `
        Preprocessing
        <select>
          <option value="split">Train-Test Split</option>
          <option value="impute">Impute Missing Values</option>
          <option value="normalize">Normalize Data</option>
        </select>
      `,
      [NodeTypes.MODEL]: `
        Model Selection
        <select>
          <option value="logistic_regression">Logistic Regression</option>
          <option value="random_forest">Random Forest</option>
          <option value="svm">Support Vector Machine</option>
          <option value="xgboost">XGBoost</option>
        </select>
      `,
      [NodeTypes.TUNE]: `
        Model Tuning
        <select>
          <option value="grid">Grid Search</option>
          <option value="random">Random Search</option>
          <option value="bayesian">Bayesian Optimization</option>
        </select>
      `,
      [NodeTypes.VALIDATE]: `
        Validation
        <select>
          <option value="cross_val">Cross-Validation</option>
          <option value="holdout">Holdout Validation</option>
        </select>
      `,
      [NodeTypes.EVALUATE]: `
        Evaluation
        <select>
          <option value="classification">Classification Metrics</option>
          <option value="regression">Regression Metrics</option>
          <option value="clustering">Clustering Metrics</option>
        </select>
      `,
      [NodeTypes.DEPLOY]: `
        Deployment
        <select>
          <option value="pickle">Save as Pickle</option>
          <option value="onnx">Export as ONNX</option>
        </select>
      `
    };

    function createNode(type, x, y) {
      const node = document.createElement('div');
      node.className = 'node';
      node.dataset.type = type;
      node.style.left = `${x}px`;
      node.style.top = `${y}px`;
      node.innerHTML = NodeTemplates[type];
      node.addEventListener('click', handleNodeClick);
      makeDraggable(node);

      // Add delete button
      const deleteButton = document.createElement('button');
      deleteButton.className = 'delete-button';
      deleteButton.textContent = 'Ã—';
      deleteButton.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent node click event
        deleteNode(node);
      });
      node.appendChild(deleteButton);

      nodes.push(node);
      document.getElementById('canvas').appendChild(node);

      // Automatically connect to the previous node if it exists
      if (nodes.length > 1) {
        const previousNode = nodes[nodes.length - 2];
        createConnection(previousNode, node);
      }

      updateConnections(); // Update connections when a new node is added
      return node;
    }

    function deleteNode(node) {
      // Remove the node from the DOM
      node.remove();

      // Remove the node from the nodes array
      nodes = nodes.filter(n => n !== node);

      // Remove any connections involving this node
      connections = connections.filter(conn => conn.from !== node && conn.to !== node);

      // Update the connections visually
      updateConnections();
    }

    function makeDraggable(node) {
      let offsetX, offsetY;
      
      node.addEventListener('mousedown', (e) => {
        offsetX = e.clientX - node.offsetLeft;
        offsetY = e.clientY - node.offsetTop;
        
        function mouseMoveHandler(e) {
          node.style.left = `${e.clientX - offsetX}px`;
          node.style.top = `${e.clientY - offsetY}px`;
          updateConnections();
        }
        
        function mouseUpHandler() {
          document.removeEventListener('mousemove', mouseMoveHandler);
          document.removeEventListener('mouseup', mouseUpHandler);
        }
        
        document.addEventListener('mousemove', mouseMoveHandler);
        document.addEventListener('mouseup', mouseUpHandler);
      });
    }

    function handleNodeClick(e) {
      if (startNode === null) {
        startNode = e.currentTarget;
      } else if (startNode !== e.currentTarget) {
        // Check if the target node already has an incoming connection
        const hasIncomingConnection = connections.some(conn => conn.to === e.currentTarget);
        
        // Check if the start node already has an outgoing connection
        const hasOutgoingConnection = connections.some(conn => conn.from === startNode);

        if (!hasIncomingConnection && !hasOutgoingConnection) {
          createConnection(startNode, e.currentTarget);
        }
        startNode = null;
      }
    }

    function createConnection(node1, node2) {
      connections.push({ from: node1, to: node2 });
      updateConnections();
    }

    function updateConnections() {
      const svg = document.querySelector('svg');
      svg.innerHTML = svg.querySelector('defs').outerHTML;
      
      connections.forEach(conn => {
        const rect1 = conn.from.getBoundingClientRect();
        const rect2 = conn.to.getBoundingClientRect();
        const canvasRect = document.getElementById('canvas').getBoundingClientRect();
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', rect1.left - canvasRect.left + rect1.width / 2);
        line.setAttribute('y1', rect1.top - canvasRect.top + rect1.height / 2);
        line.setAttribute('x2', rect2.left - canvasRect.left + rect2.width / 2);
        line.setAttribute('y2', rect2.top - canvasRect.top + rect2.height / 2);
        svg.appendChild(line);
      });
    }

    document.querySelectorAll('.component').forEach(comp => {
      comp.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', comp.dataset.type);
      });
    });

    document.getElementById('canvas').addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    document.getElementById('canvas').addEventListener('drop', (e) => {
      e.preventDefault();
      const type = e.dataTransfer.getData('text/plain');
      const canvasRect = document.getElementById('canvas').getBoundingClientRect();
      const x = e.clientX - canvasRect.left;
      const y = e.clientY - canvasRect.top;
      createNode(type, x, y);
    });

    document.addEventListener('change', (e) => {
      if (e.target.type === 'file') {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            const csvData = event.target.result;
            userData = parseCSV(csvData);
          };
          reader.readAsText(file);
        }
      }
    });

    function parseCSV(csvData) {
      const rows = csvData.trim().split('\n');
      const headers = rows[0].split(',');
      return rows.slice(1).map(row => {
        const values = row.split(',');
        return headers.reduce((obj, header, index) => {
          obj[header] = values[index];
          return obj;
        }, {});
      });
    }

    document.getElementById('generateButton').addEventListener('click', async () => {
      if (!userData) {
        alert('Please upload a dataset first!');
        return;
      }
      
      if (!apiKey) {
        alert('Please enter a valid Gemini API key!');
        return;
      }
      
      const workflow = nodes.map(node => ({
        type: node.dataset.type,
        config: node.querySelector('select')?.value
      }));
      
      const generateButton = document.getElementById('generateButton');
      const generatedCode = document.getElementById('generatedCode');
      
      // Disable the button and update its text
      generateButton.disabled = true;
      generateButton.textContent = 'Generating code...';
      generatedCode.textContent = '';
      
      const prompt = `
        Generate Python code for the following ML workflow:
        ${JSON.stringify(workflow)}
        Dataset sample: ${JSON.stringify(userData.slice(0, 5))}
        Include preprocessing, model training, and evaluation.
      `;
      
      try {
        const code = await generateWithGemini(prompt);
        generatedCode.textContent = code;
      } catch (error) {
        generatedCode.textContent = 'Error generating code: ' + error.message;
      } finally {
        // Re-enable the button and reset its text
        generateButton.disabled = false;
        generateButton.textContent = 'Generate Code';
      }
    });

    async function generateWithGemini(prompt) {
      const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
      
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }]
        })
      });
      
      const data = await response.json();
      if (response.ok && data.candidates?.[0]?.content?.parts?.[0]?.text) {
        return data.candidates[0].content.parts[0].text;
      } else {
        throw new Error('Failed to generate code');
      }
    }
  </script>
</body>
</html>